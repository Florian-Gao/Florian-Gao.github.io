<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jupyter-notebook]]></title>
    <url>%2F2019%2F09%2F05%2Fjupyter-notebook%2F</url>
    <content type="text"><![CDATA[install对于Anacanda安装，如果没有，命令行 1conda install jupyter notebook operate jupyter notebookhelp123jupyter notebook --helporjupyter notebook --h launch1jupyter notebook designated port start1234jupyter notebook --port&lt;port_number&gt;such asjupyter notebook --port 9999#start at port 9999 快捷方式y/m 代码/markdown转换a/d 在上方建立代码块/下方建立代码块c/x/v 复制/剪切/粘贴d deleteh 出现快捷键l 代码标行数$公式输入，行内$$ 公式输入，单独行]]></content>
      <tags>
        <tag>jumpter-notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础2]]></title>
    <url>%2F2019%2F09%2F05%2Fpython%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[人工智能]]></title>
    <url>%2F2019%2F09%2F05%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2F</url>
    <content type="text"></content>
      <tags>
        <tag>python</tag>
        <tag>mechine learning</tag>
        <tag>advanced mathematics/高数</tag>
        <tag>Neural Network</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiprocessing/多进程]]></title>
    <url>%2F2019%2F09%2F04%2FMultiprocessing%2F</url>
    <content type="text"><![CDATA[import12import multiprocessing as mpimport threading as td 定义一个被线程和进程调用的函数12def job(a,d) print(&apos;aaaa&apos;) 创建线程和进程注意：Thread和Process的首字母都要大写，被调用的函数没有括号，被调用的函数的参数放在args(…)中 12t1=td.Thread(target=job,args=(1,2))p1 = mp.Process(target=job,args=(1,2)) 启动线程和进程12t1.start()p1.start() 分别连接线程和进程12t1.join()d1.join() full code123456789101112import multiprocessing as mpimport threading as tddef job(a,d): print(&apos;aaaaa&apos;)t1 = td.Thread(target=job,args=(1,2))p1 = mp.Process(target=job,args=(1,2))t1.start()p1.start()t1.join() # 分别连接线程和进程p1.join() use1if __name__=&apos;__main__&apos; 123456789import multiprocessing as mpdef job(a,d): print(&apos;aaaaa&apos;)if __name__==&apos;__main__&apos;: p1 = mp.Process(target=job,args=(1,2)) p1.start() p1.join() Queen #use to store process12345678910111213141516171819import multiprocessing as mpdef job(q): res=0 for i in range(1000): res+=i+i**2+i**3 q.put(res) #queue put data in queenif __name__==&apos;__main__&apos;: q = mp.Queue() p1 = mp.Process(target=job,args=(q,)) p2 = mp.Process(target=job,args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() #get the data res2 = q.get() print(res1+res2) multiprocessing and threading compare12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import multiprocessing as mpimport threading as tdimport timedef job(q): res = 0 for i in range(1000000): res += i+i**2+i**3 q.put(res) # queuedef multicore(): q = mp.Queue() p1 = mp.Process(target=job, args=(q,)) p2 = mp.Process(target=job, args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print(&apos;multicore:&apos; , res1+res2)def normal(): res = 0 for _ in range(2): for i in range(1000000): res += i+i**2+i**3 print(&apos;normal:&apos;, res)def multithread(): q = mp.Queue() t1 = td.Thread(target=job, args=(q,)) t2 = td.Thread(target=job, args=(q,)) t1.start() t2.start() t1.join() t2.join() res1 = q.get() res2 = q.get() print(&apos;multithread:&apos;, res1+res2)if __name__ == &apos;__main__&apos;: st = time.time() normal() st1= time.time() print(&apos;normal time:&apos;, st1 - st) multithread() st2 = time.time() print(&apos;multithread time:&apos;, st2 - st1) multicore() print(&apos;multicore time:&apos;, time.time()-st2)finally, we find multicore is the fastest, multithread is the slowest Pool #the processing pool`pool will get a return value, but process can’t get the return value.’pool call the core of CPU, the parameter of processing can design the core’s number of CPU 1234567891011121314151617import multiprocessing as mpdef job(x): return x*xdef multicore(): pool = mp.Pool(processes=2) # define the pool, the num in braket(括号) is the core&apos;s num res = pool.map(job, range(10)) # return results print(res) #[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] res = pool.apply_async(job, (2,)) #this way can only get one result, and it will be put in only one core to calculate, attention ,there is a comma（逗号） print(res.get()) multi_res =[pool.apply_async(job, (i,)) for i in range(10)] #put into iterator print([res.get() for res in multi_res]) # get from the iteratorif __name__ == &apos;__main__&apos;: multicore() share memory (共享内存)shared value12345import multiprocessing as mpvalue1 = mp.Value(&apos;i&apos;, 0) value2 = mp.Value(&apos;d&apos;, 3.14)# i、d 是设置数据类型的，i代表带符号的整型，d代表双精度浮点类型 shared array1234567array = mp.Array(&apos;i&apos;, [1, 2, 3, 4]) # is rightarray = mp.Array(&apos;i&apos;, [[1, 2], [3, 4]]) # 2维list&quot;&quot;&quot;TypeError: an integer is required&quot;&quot;&quot;## Array is different from numpy, it only be one dimensional, can&apos;t be multi-dimensional parametric data form processing lockno lock1234567891011121314151617181920import multiprocessing as mpimport timedef job(v, num): for _ in range(5): time.sleep(0.1) # 暂停0.1秒，让输出效果更明显 v.value += num # v.value获取共享变量值 print(v.value, end=&quot;&quot;) def multicore(): v = mp.Value(&apos;i&apos;, 0) # 定义共享变量 p1 = mp.Process(target=job, args=(v,1)) p2 = mp.Process(target=job, args=(v,3)) # 设定不同的number看如何抢夺内存 p1.start() p2.start() p1.join() p2.join() if __name__ == &apos;__main__&apos;: multicore() the result/ process 1 and process 2 battle for the shared memory 12345678910145891213161720 if we add process lock ## l=mp.lock()1234567891011121314151617181920def job(v, num, l): l.acquire() # 锁住 for _ in range(5): time.sleep(0.1) v.value += num # 获取共享内存 print(v.value) l.release() # 释放def multicore(): l = mp.Lock() # 定义一个进程锁 v = mp.Value(&apos;i&apos;, 0) # 定义共享内存 p1 = mp.Process(target=job, args=(v,1,l)) # 需要将lock传入 p2 = mp.Process(target=job, args=(v,3,l)) p1.start() p2.start() p1.join() p2.join()if __name__ == &apos;__main__&apos;: multicore() the result #when p 1 is done, p 2 begins 1234567891012345811141720]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E5%9F%BA%E7%A1%80%2F20190901-python%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[pythonprint用法123print(&apos;&apos;)字符串要单引号或双引print(&apos;hello&apos;+&apos;python&apos;)这样字符串可以进行连接python(3+1)运算不需要引号 基本运算12^在matlab中是平方，在python是**表示平方%取余 变量12a,b,c=1,2,3print(a) while1234a=10while a; print(a) a=a-1 for循环123list=[1,2,3,4]for i in list; print(i) 1234range使用range(start,stop)左开右闭range(stop)=range(0,stop)range(start,stop,step) 高级主题内置集合12345tuple 元组 元组内元素不可改变tup=(&apos;python&apos;,2.4,64)for i in tup; print(i)出来的是tup内的三个元素 1234567dicdic=&#123;&#125;dic[&apos;a&apos;]=&apos;python&apos;dic[&apos;b&apos;]=2.5for k in dic; print(k,dic[k])这个里面k相当于字典的目录，检索功能 12345set 可以去重s=set([&apos;a&apos;,&apos;s&apos;,&apos;d&apos;,&apos;a&apos;])for i in s; print(i)输出只有a,s,d,就会少一个a 生成器12345678910111213yield 每次执行，立刻返回结果给上层调用者，而当前状态保留 def fib(max); a,b=0,1; while max; r=b a,b=b,a+b max-=1 yield r for i in fib(5); print(i)输出为1，1，2，3，5 if12if x==y; print(x) 这是对的，如果x=y 就是赋值 12345678if condition: print()elif condition2: print()elif condition3: print()else: print() def 自建函数123456def fun(): print(&apos;hahaha&apos;) a=1+2 print(a)fun() 123456def sale_car(price, color=&apos;red&apos;, brand=&apos;carmy&apos;, is_second_hand=True): print(&apos;price&apos;, price, &apos;color&apos;, color, &apos;brand&apos;, brand, &apos;is_second_hand&apos;, is_second_hand,)注意这的逗号调用sale_car(1000),sale_car(1000, &apos;red&apos;, &apos;carmy&apos;, True) 都可以，出现的一样的结果 可变参数，*参数，相当于列表1234567def report(name, *grades) #这里grades是可变参数，可以是可迭代对象 total_report=0 for grade in grades: total_grade+=grade print(name,&apos;total grade is &apos;,total_grade)#调用report(&apos;mike&apos;,8,9,7) 关键字参数，**参数，相当于字典123456def portrait(name, **kw): print(&apos;name is&apos;, name) for k,v in kw.items(): print(k, v)#调用portrait(&apos;Mike&apos;, age=24, country=&apos;China&apos;, education=&apos;bachelor&apos;) 1通过可变参数和关键字参数，任何函数都可以用 universal_func(*args, **kw) 表达 全局/局部变量123456789101112全局变量APPLY = 100 # 全局变量a = Nonedef fun(): global a # 使用之前在全局里定义的 a a = 20 # 现在的 a 是全局变量了 return a+100print(APPLE) # 100print(&apos;a past:&apos;, a) # Nonefun()print(&apos;a now:&apos;, a) # 20 1234567局部变量def fun(): a = 10 print(a) return a+100print(fun()) 读写文件123\n #换行\t #对齐，tap对齐file=open(&apos;my file.txt&apos;,&apos;w&apos;) #w写文件，如果没有，会新建一个,r读文件，a append新增内容，需要提前有文件 1234append_text=&apos;\nThis is appended file.&apos; # 为这行文字提前空行 &quot;\n&quot;my_file=open(&apos;my file.txt&apos;,&apos;a&apos;) # &apos;a&apos;=append 以增加内容的形式打开,然而w是覆盖写入my_file.write(append_text) # 往原文件里添加了一句my_file.close() 读取文件123file=open(&apos;file.txt&apos;,&apos;r&apos;)content=file.read()print(content) 123456789按行读取file= open(&apos;my file.txt&apos;,&apos;r&apos;) content=file.readlines() # python_list 形式print(content)orfor item in content: print(item) class12345678910111213141516171819class Calculator: #首字母要大写，冒号不能缺 name=&apos;Good Calculator&apos; #该行为class的属性 price=18 def add(self,x,y): print(self.name) result = x + y print(result) def minus(self,x,y): result=x-y print(result) def times(self,x,y): print(x*y) def divide(self,x,y): print(x/y)定义类之后，其他的用的调用cal=Calculator() #注意这里运行class的时候要加&quot;()&quot;,否则调用下面函数的时候会出现错误,导致无法调用.cal.namecal.times init 初始化12345678910class Calculator: name=&apos;good calculator&apos; price=18 def __init__(self,name,price,height,width,weight): # 注意，这里的下划线是双下划线 self.name=name self.price=price self.h=height self.wi=width self.we=weightc=Calculator(&apos;bad calculator&apos;,18,17,16,15) #初始化运行 input1234567891011score=int(input(&apos;Please input your score: \n&apos;)) #用int取整if score&gt;=90: print(&apos;Congradulation, you get an A&apos;)elif score &gt;=80: print(&apos;You get a B&apos;)elif score &gt;=70: print(&apos;You get a C&apos;)elif score &gt;=60: print(&apos;You get a D&apos;)else: print(&apos;Sorry, You are failed &apos;) 元组，列表，字典元组tuple1turple=（1，2，3，‘python’） #括号，不可改变 列表list1list=[1,2,3,&apos;py&apos;] #列表用书名号 多维列表123list=[[1,2,3], [2,3,4], [3,4,5]] #三行三列 list添加123456789101112list=[1,2,3]list.append(0) #在末尾加list.insert(1,0) #在位置1 添加0list.remove(2) #移除列表中数字为2的数字print(list[1]) #列表第0位数字print（list[-1]） #列表最后一位数字print(list[0][1]) #多维列表的索引print(list.index(2)) #在列表中第一次出现2 的项的索引print(list.count(2)) #列表中2 出现的次数print(list.sort()) #从小到大排序print(list.sort(reverse=True)) #从大到小排序 list和元组输出对比123456789101112131415161718for index in range(len(a_list)): print(&quot;index = &quot;, index, &quot;, number in list = &quot;, a_list[index])&quot;&quot;&quot;index = 0 , number in list = 12index = 1 , number in list = 3index = 2 , number in list = 67index = 3 , number in list = 7index = 4 , number in list = 82&quot;&quot;&quot;for index in range(len(a_tuple)): print(&quot;index = &quot;, index, &quot;, number in tuple = &quot;, a_tuple[index])&quot;&quot;&quot;index = 0 , number in tuple = 12index = 1 , number in tuple = 3index = 2 , number in tuple = 5index = 3 , number in tuple = 15index = 4 , number in tuple = 6 字典dic 分key和value123456789101112131415举例分析a_list = [1,2,3,4,5,6,7,8]d1 = &#123;&apos;apple&apos;:1, &apos;pear&apos;:2, &apos;orange&apos;:3&#125;d2 = &#123;1:&apos;a&apos;, 2:&apos;b&apos;, 3:&apos;c&apos;&#125;d3 = &#123;1:&apos;a&apos;, &apos;b&apos;:2, &apos;c&apos;:3&#125;print(d1[&apos;apple&apos;]) # 1print(a_list[0]) # 1del d1[&apos;pear&apos;]print(d1) # &#123;&apos;orange&apos;: 3, &apos;apple&apos;: 1&#125;d1[&apos;b&apos;] = 20print(d1) # &#123;&apos;orange&apos;: 3, &apos;b&apos;: 20, &apos;pear&apos;: 2, &apos;apple&apos;: 1&#125; 字典内字典，字典内数组12345def func(): return 0d4 = &#123;&apos;apple&apos;:[1,2,3], &apos;pear&apos;:&#123;1:3, 3:&apos;a&apos;&#125;, &apos;orange&apos;:func&#125;print(d4[&apos;pear&apos;][3]) # a import123456789101112firstimport time as tprint(t.localtime())secondfrom time import time, localtime #只import想要的功能print(localtime())print(time)thirdfrom time import * #输入模块全部功能print(localtime()) continue and breakpass 过了这一步，从头开始而break直接跳出循环continue会直接不进行下面的，直接进行下一次循环1234567891011121314151617a=Truewhile a: b= input(&apos;type somesthing&apos;) if b==&apos;1&apos;: a= False else: passprint (&apos;finish run&apos;)&apos;&apos;&apos;&apos;type somesthing:2still in whiletype somesthing:3still in whiletype somesthing:1still in while #会执行下面的语句再跳出finish run 12345678910111213141516while True: b=input(&apos;input somesthing:&apos;) if b==&apos;1&apos;: continue else: pass print(&apos;still in while&apos; )print (&apos;finish run&apos;)&quot;&quot;&quot;input somesthing:3still in whileinput somesthing:1 # 没有&quot;still in while&quot;。直接进入下一次循环input somesthing:4still in whileinput somesthing: try 错误处理123456789101112131415处理错误：会使用到循环语句。首先报错：没有这样的文件No such file or directory. 然后决定是否输入y, 输入y以后，系统就会新建一个文件（要用写入的类型）， 再次运行后，文件中就会写入sssstry: file=open(&apos;eeee.txt&apos;,&apos;r+&apos;)except Exception as e: print(e) response = input(&apos;do you want to create a new file:&apos;) if response==&apos;y&apos;: file=open(&apos;eeee.txt&apos;,&apos;w&apos;) else: passelse: file.write(&apos;ssss&apos;) file.close() zip 将两个列表，合成一个tuple1234567891011121314a=[1,2,3]b=[4,5,6]ab=zip(a,b)print(list(ab)) #list 是可视化ab&quot;&quot;&quot;[(1, 4), (2, 5), (3, 6)]&quot;&quot;&quot;for i,j in zip(a,b): #合并之后是哟=一个里面有两个值 print(i/2,j*2)&quot;&quot;&quot;0.5 81.0 101.5 12 lambda 定义了一个函数123456789fun= lambda x,y:x+yx=int(input(&apos;x=&apos;)) #这里要定义int整数，否则会默认为字符串y=int(input(&apos;y=&apos;))print(fun(x,y))&quot;&quot;&quot;x=6y=612 map 把函数和参数绑定在一起12345678910&gt;&gt;&gt; def fun(x,y): return (x+y)&gt;&gt;&gt; list(map(fun,[1],[2]))&quot;&quot;&quot;[3]&quot;&quot;&quot;&gt;&gt;&gt; list(map(fun,[1,2],[3,4]))&quot;&quot;&quot;[4,6]&quot;&quot;&quot; copy &amp; deepcopy123456789101112import copya=[1,2,3]a=b&gt;&gt;&gt;id(a)=id(b)Truec=copy.copy(a)&gt;&gt;&gt;print(id(a)==id(c))False&gt;&gt;&gt;c[1]=222&gt;&gt;&gt;print(c)c=[1,2222,3]&gt;&gt;&gt;d=copy.deepcopy(a) set 找不同set基本，找一个语句或者list中的不同的元素123456789101112char_list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;c&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;]sentence = &apos;Welcome Back to This Tutorial&apos;print(set(char_list))# &#123;&apos;b&apos;, &apos;d&apos;, &apos;a&apos;, &apos;c&apos;&#125;print(set(sentence))# &#123;&apos;l&apos;, &apos;m&apos;, &apos;a&apos;, &apos;c&apos;, &apos;t&apos;, &apos;r&apos;, &apos;s&apos;, &apos; &apos;, &apos;o&apos;, &apos;W&apos;, &apos;T&apos;, &apos;B&apos;, &apos;i&apos;, &apos;e&apos;, &apos;u&apos;, &apos;h&apos;, &apos;k&apos;&#125;print(set(char_list+ list(sentence)))# &#123;&apos;l&apos;, &apos;m&apos;, &apos;a&apos;, &apos;c&apos;, &apos;t&apos;, &apos;r&apos;, &apos;s&apos;, &apos; &apos;, &apos;d&apos;, &apos;o&apos;, &apos;W&apos;, &apos;T&apos;, &apos;B&apos;, &apos;i&apos;, &apos;e&apos;, &apos;k&apos;, &apos;h&apos;, &apos;u&apos;, &apos;b&apos;&#125; add 添加元素123456unique_char = set(char_list)unique_char.add(&apos;x&apos;)### unique_char.add([&apos;y&apos;, &apos;z&apos;]) this is wrongprint(unique_char)# &#123;&apos;x&apos;, &apos;b&apos;, &apos;d&apos;, &apos;c&apos;, &apos;a&apos;&#125; remove &amp; discard 清除某个元素，，，clear清除全部筛选 difference看有没有不同的元素，intersection看有没有相同的元素123456unique_char = set(char_list)print(unique_char.difference(&#123;&apos;a&apos;, &apos;e&apos;, &apos;i&apos;&#125;))# &#123;&apos;b&apos;, &apos;d&apos;, &apos;c&apos;&#125;print(unique_char.intersection(&#123;&apos;a&apos;, &apos;e&apos;, &apos;i&apos;&#125;))# &#123;&apos;a&apos;&#125; 正则化//用于搜索，网络爬虫，文件整理，数据筛选之类匹配1234567import re # 内置模块# regular expressionpattern1 = &quot;cat&quot;pattern2 = &quot;bird&quot;string = &quot;dog runs to cat&quot;print(re.search(pattern1, string)) # &lt;_sre.SRE_Match object; span=(12, 15), match=&apos;cat&apos;&gt;print(re.search(pattern2, string)) # None 灵活匹配12345678# multiple patterns (&quot;run&quot; or &quot;ran&quot;)ptn = r&quot;r[au]n&quot; # start with &quot;r&quot; means raw string, 括号里面的是可变内容print(re.search(ptn, &quot;dog runs to cat&quot;))print(re.search(r&quot;r[A-Z]n&quot;, &quot;dog runs to cat&quot;)) # Noneprint(re.search(r&quot;r[a-z]n&quot;, &quot;dog runs to cat&quot;)) # &lt;_sre.SRE_Match object; span=(4, 7), match=&apos;run&apos;&gt;print(re.search(r&quot;r[0-9]n&quot;, &quot;dog r2ns to cat&quot;)) # &lt;_sre.SRE_Match object; span=(4, 7), match=&apos;r2n&apos;&gt;print(re.search(r&quot;r[0-9a-z]n&quot;, &quot;dog runs to cat&quot;)) # &lt;_sre.SRE_Match object; span=(4, 7), match=&apos;run&apos;&gt; 按类型匹配 \d : 任何数字 \D : 不是数字 \s : 任何 white space, 如 [\t\n\r\f\v] \S : 不是 white space \w : 任何大小写字母, 数字和 “” [a-zA-Z0-9] \W : 不是 \w \b : 空白字符 (只在某个字的开头或结尾) \B : 空白字符 (不在某个字的开头或结尾) \ : 匹配 \ . : 匹配任何字符 (除了 \n) ^ : 匹配开头 $ : 匹配结尾 ? : 前面的字符可有可无有时^会出问题，如果用通常的形式是不成功的. 比如下面的 “I” 出现在第二行开头, 但是使用 r”^I” 却匹配不到第二行, 这时候, 我们要使用 另外一个参数, 让 re.search() 可以对每一行单独处理. 这个参数就是 flags=re.M, 或者这样写也行 flags=re.MULTILINE.123456string = &quot;&quot;&quot;dog runs to cat.I run to dog.&quot;&quot;&quot;print(re.search(r&quot;^I&quot;, string)) # Noneprint(re.search(r&quot;^I&quot;, string, flags=re.M)) # &lt;_sre.SRE_Match object; span=(18, 19), match=&apos;I&apos;&gt; 重复匹配 : 重复零次或多次 : 重复一次或多次 {n, m} : 重复 n 至 m 次 {n} : 重复 n 次 1234567891011# * : occur 0 or more timesprint(re.search(r&quot;ab*&quot;, &quot;a&quot;)) # &lt;_sre.SRE_Match object; span=(0, 1), match=&apos;a&apos;&gt;print(re.search(r&quot;ab*&quot;, &quot;abbbbb&quot;)) # &lt;_sre.SRE_Match object; span=(0, 6), match=&apos;abbbbb&apos;&gt;# + : occur 1 or more timesprint(re.search(r&quot;ab+&quot;, &quot;a&quot;)) # Noneprint(re.search(r&quot;ab+&quot;, &quot;abbbbb&quot;)) # &lt;_sre.SRE_Match object; span=(0, 6), match=&apos;abbbbb&apos;&gt;# &#123;n, m&#125; : occur n to m timesprint(re.search(r&quot;ab&#123;2,10&#125;&quot;, &quot;a&quot;)) # Noneprint(re.search(r&quot;ab&#123;2,10&#125;&quot;, &quot;abbbbb&quot;)) # &lt;_sre.SRE_Match object; span=(0, 6), match=&apos;abbbbb&apos;&gt; 分组 match.group()1234match = re.search(r&quot;(\d+), Date: (.+)&quot;, &quot;ID: 021523, Date: Feb/12/2017&quot;)print(match.group()) # 021523, Date: Feb/12/2017print(match.group(1)) # 021523print(match.group(2)) # Date: Feb/12/2017 如果给组定义个名字 ?p&lt;name&gt;123match = re.search(r&quot;(?P&lt;id&gt;\d+), Date: (?P&lt;date&gt;.+)&quot;, &quot;ID: 021523, Date: Feb/12/2017&quot;)print(match.group(&apos;id&apos;)) # 021523print(match.group(&apos;date&apos;)) # Date: Feb/12/2017 找到所有项 findall12345# findallprint(re.findall(r&quot;r[ua]n&quot;, &quot;run ran ren&quot;)) # [&apos;run&apos;, &apos;ran&apos;]# | : orprint(re.findall(r&quot;(run|ran)&quot;, &quot;run ran ren&quot;)) # [&apos;run&apos;, &apos;ran&apos;] replace re.sub()1print(re.sub(r&quot;r[au]ns&quot;, &quot;catches&quot;, &quot;dog runs to cat&quot;)) # dog catches to cat 分割 split1print(re.split(r&quot;[,;\.]&quot;, &quot;a;b,c.d;e&quot;)) # [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] compile 搜索12compiled_re = re.compile(r&quot;r[ua]n&quot;)print(compiled_re.search(&quot;dog ran to cat&quot;)) # &lt;_sre.SRE_Match object; span=(4, 7), match=&apos;ran&apos;&gt; 小抄]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook使用指南]]></title>
    <url>%2F2019%2F09%2F02%2Fgitbook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F20190901-gitbook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[gitbook安装node.js安装好后，sudo su 进入root模式node -v 查看版本npm -v 查看版本npm install -g cnpm –registry=https://registry.npm.taobao.org建立淘宝镜像,更快一些（cnpm）c n p m cnpm install -g gitbook-clicnpm -v 查看版本建立自己blog文件夹 cd Users/Florian_Gao/Desktop/gitpwd 查看一下位置mkdir gitbookpwdgitbook init生成安装hexo gitbook init启动hexo 这里是gitbook serve 不能简写 简单书写markdown 换行 ··· ···出现的是代码框 写的文字内容改变文字颜色 · · 这是行内代码 外部链接 就直接在后面添加网址地址就好 子目录 *介绍 子目录注意前面有两个空格插件npm搜gitbook就可以插件要在文件book.json中，所以要自己新建把插件弄好后要gitbook install上传GitHub先在GitHub建立一个repo然后在本地建文件夹 git init然后把文件夹clone过来 git remote add origin git@github.com:Florian-Gao/仓库名.git然后把书上传 git add .git commit -m “reason”最后上传 git push -u origin master当然也可以建立分支上传]]></content>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F09%2F01%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F20190901-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客安装node.js安装好后，sudo su 进入root模式node -v查看版本npm -v 查看版本npm install -g cnpm --registry=https://registry.npm.taobao.org建立淘宝镜像,更快一些（cnpm） c n p mcnpm install -g hexo-clicnpm -v查看版本 建立自己blog文件夹cd Users/Florian_Gao/Desktop/git pwd 查看一下位置mkdir blogpwd 生成安装hexosudo hexo init 启动hexohexo s 部署到gitbub在repo中建立一个.github.io在系统blog文件夹中部署一个git的插件cnpm install --save hexo-deployer-git``ll还要设置里面一个文件_config.yml用vim _config.yml进行修改修改deployer 123type： gitrepo： 自己仓库的地址branch： master 注意：上面三个都要在冒号后面有空格有视频 https://www.bilibili.com/video/av23211850?t=206 部署到远端hexo d在github上刷新，输入 Florian-Gao.github.io即可访问 更换hexo主题github.com/litten/hexo-theme-yilia 在blog文档下进行 pwd看下克隆过来到本地blog/themes/yiliagit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 仍然进入vim _config.yml进行修改theme，改成你想要的主题的名字就可以了 12345hexo clean 清理一下hexo g 生成一下，generatorhexo s 重开一下hexo d 推到远端hexo g -d 生成推送 更改主题在主文件夹_config.yml进行修改titlesubtitle 如果修改发的文章的地址，在URL中permalink进行修改添加图片，要 /路径空格➕路径 基本写作hexo new &lt;filename&gt;如果名字有空格，要加引号标题 new_post_name 进行更改即可update: 可以现实更新时间 123456tags: 如果一个标签就直接在后面写就可以 -pythin -mechine learning 前面两个空格，一个横线，并列着写，并列着写categories： -animals -cat 不支持同级分类，是父级和子集 文章内插入图片12345678910本地图片 文件放在 source/images文件夹中 markdown格式 ![提示文字](/images/test.jpg) html &lt;img src=&quot;图片路径&quot; alt=&quot;提示文字&quot;&gt;网络图片 直接把网络地址的粘进去就可以，两个都可以好用的图片库 imgur 图片下载格式已经帮你弄好了 视频代码直接粘过来就可以12345iframe格式 通用模式就可以 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=65746051&amp;cid=114072844&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 如果要是更改长宽 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=65746051&amp;cid=114072844&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot; height=&quot;450&quot;&gt; &lt;/iframe&gt; 这样就可以了 插入音频，配合文字先上传到网易云音乐也可以申请电台具体操作https://blog.csdn.net/Mculover666/article/details/90700059 文章没插入网址链接12345678类似于超链接 markdown [想说的东西](网址的地址) [有趣的网站](https://music.163.com) html &lt;a href=&quot;网址&quot;&gt;解释的内容&lt;/a&gt; &lt;a href=&quot;https://music.163.com&quot;&gt;网易云&lt;/a&gt; 直接把网址粘过去就可以]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用指南]]></title>
    <url>%2F2019%2F08%2F31%2Fgit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F20190831-git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[gitgit常用命令 git简介··· 工作区/Working Directory 在自己电脑可以看到的 版本区/Repository 当我们git add 就是放到暂存区当git commit 就是将文件从暂存区到分支··· 安装git（mac）在终端输入git –version就可以安装了创建版本库1234创建储存的文件夹 mkdir learngit变为git存储库 git init在文件夹中创建文件 touch readme.txt添加到仓库 git add readme.txt 123git add &lt;文件名&gt;可以同时添加多个文件 提交到仓库 git commit -m &quot;注释&quot; 时间穿梭机基本操作123打开文件 touch &lt;文件名&gt;看状态 git status看修改过的内容 git diff &lt;文件名&gt; 后退至之前版本看从最近到最远提交的日志 git log输出参数 git log --pretty=oneline回到以前的版本 git reset --hard 1094a1094a 为输入git log --pretty=oneline后出现的head代号HEAD^上个版本HEAD^^上上个版本HEAD～100上一百的版本回到上个版本 git reset --hard HEAD^ 前进至未来版本退到以前的版本之后，就不能再回到这个版本之后的版本，用git reflog之后再用git reset --hard &lt;HEAD&gt; 管理修改git管理的是修改，如果没有git add，直接git commit，那样不会上传，具体步骤 1第一次修改-&gt;git add-&gt;第二次修改-&gt;git add-&gt;git commit 撤销修改如果还未git add，即未将文件从工作区传到暂存区，使用git checkout --&lt;文件名&gt;git checkout就是从版本去的文件替换工作区的文件如果已经git add,可以使用 git reset HEAD &lt;文件名&gt;这个命令既可以回退版本，又可以把暂存区的内容修改并回退回工作区，下次仍要git add如果已经 git add，并且git commit，那样就要使用命令git reset --hard HEAD^如果同步到远程库，gg 删除文件删除文件 rm &lt;文件名&gt;删除文件夹 rm -rf &lt;&gt;如果从版本库删除 git rm &lt;文件名&gt;，然后git commit如果误删工作区的文件，使用git checkout --&lt;文件名&gt;git checkout就是从版本去的文件替换工作区的文件 远程仓库github具体步骤创建SSH Key-t rsa -C “your email”1打开id_rsa.pub cat id_rsa.pub 登录github12打开 Account setting--SSH Keys--Add SSH Key填写任意title，在Key粘贴 id_rsa.pub的内容 添加远程库在github上新建新的仓库repository1/与本地的仓库关联 git remote add origin git@github.com:Florian-Gao/仓库名.git2/git push -u origin master 把内容推到远程库3/之后只需要git push origin master 创建远程库和添加远程库结合起来就可以在GitHub中进行更新从远程库克隆首先在远程库中新建repo，勾选initialize this repository with a readme ,建成之后会有一个readme文件找好位置，clone在命令行git clone git@github.com:Florian-Gao/文件名.git 分支管理创建合并分支master分支是主分支可创建新的分支，并在新的分支上进行编辑 等新的分支上工作完成，可以进行分支的合并 创建dev分支，切换到dev分支12345git checkout -b dev #-b 相当于切换 ，两个命令的叠加 git branch dev //git checkout devgit branch 查看当前分支，当前分支会有一个*号然后在此分支进行上传 git add &lt;文件名&gt;//git commit -m &quot;reason&quot;在此分支上完成工作，可以回到主分支，git checkout master在dev分支提交的内容在master分支看不到 12将dev分支合并到当前分支，git merge dev合并在当前分支就能查看编辑dev上的内容了，也就用不到dev分支了，删除git branch -d dev 切换分支刚才说得 git checkout &lt;分支名&gt;，但是之前所说的未git add的工作区文件，直接用git checkout --&lt;文件名&gt;这里有重复，可以用新的命令 git switch 创建并切换新的分支123git switch -c dev直接切换已有的分支git switch master 分支管理命令小结123456789101112131415 查看分支git branch 重命名分支名 git branch -m &lt;当前分支名&gt; &lt;新的分支名&gt; 创建分支git branch &lt;name&gt; 切换分支git checkout &lt;name&gt; or git switch &lt;name&gt; 创建切换分支 git checkout -b &lt;name&gt; or git switch -c &lt;name&gt; 合并某分支到当前分支git merge &lt;name&gt; git merge &lt;branch&gt; 这个就是直接合并，不保留分支内容git merge --on-ff -m &quot;reason&quot; &lt;branch&gt;这种方法合并仍有分支内容在，可以仍在分支上进行工作 删除分支git branch -d &lt;name&gt; 恢复分支 git log 查看分支的提出号git branch &lt;分支名称&gt;&lt;提交号&gt; 查看分支图git log --graph让分支图更清晰git log --graph --pretty=oneline --abbrev-commit 如果合并的时候，分支文件不同，合并出现问题，需要手动进行更改分支合并策略12345678910111213141516171819202122232425262728git merge &lt;branch&gt; 这个就是直接合并，不保留分支内容git merge --on-ff -m &quot;reason&quot; &lt;branch&gt;这种方法合并仍有分支内容在，可以仍在分支上进行工作bug管理 如果在分支dev工作，遇到master上有bug git stash还不想提交dev上的内容，可以使用这个指令存储 处理bug 首先进到mastergit checkout master然后在master建立临时分支‘debug’git checkout -b debug处理完bug之后git add &lt;file.name&gt;git commit -m &quot;reason&quot;回到主分支git checkout master合并debug分支git merge --on-ff -m &quot;reason&quot; &lt;file.name&gt;处理完bug之后，进入dev继续工作git checkout dev 因为master有问题，dev也是master上分出来的，所以也会有这种问题，简单方法git checkout devgit cherry-pick &lt;commit&gt;这里是commit的命令数字也就是HEAD同理，在dev上修改bug之后，也可以在master上修改，方式一样，只是在dev上先保存git stash 处理完bug，回到dev git status会发现nothing，这是git把stash存放在某一地方用git stash list来看是否还在 恢复方法，有两种123一，git stash pop 恢复并把stash内容删掉二，git stash apply 恢复 git stash drop 把stash删掉 有新功能添加进来12345git checkout -b featuregit add new.pygit commit -m &quot;set new&quot;git checkout devgit merge --on-ff -m &quot;new merge&quot; feature 但是现在说feature不能要，要删掉，怎么办 用之前所学 1git branch -d feature 发现error，这个时候就要用 1git branch -D feature 强制删除 多人协作 12git remote 查看远程库的信息git remote -v 查看更详细的信息 推送分支 123git push &lt;库名&gt; &lt;分支名&gt;git push origin mastergit push origin dev 打算上传哪个分支看自己另一个人克隆不是自己的文件 123git clone git@github.com:Florian-Gao/库名.git想在dev分支开发，要创建远程origin的dev分支到本地git checkout -b dev origin/dev 1234git checkout -b dev origin/devgit add &lt;file.name&gt;git commit -m &quot;&quot;git push origin dev 你的朋友提交了，恰好你也要提交 123git addgit commitgit push 然后你发现false，因为这个伙伴比你提交的快要怎么办呢首先 12345git pull 把最新的提交从origin/dev抓下来，在本地合并，解决冲突，再推送如果失败，是因为没有制定本地的dev分支与远程origin/dev分支链接git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;再pullgit pull 但是会出现问题，合并有问题，手动解决（解决冲突），再push 多人协作的git log的线路非常乱12git rebase可以使线路变成单路，更清晰 标签管理如果有了标签，找起来更加好找 标签只能对commit进行标记 标签不是时间顺序，而是按照字母顺序创建标签 git tag 12345678创建带指定信息的标签git tag -a &lt;tagname&gt; -m &quot;reason&quot;查看标签 git tag对commit进行标签 git tag &lt;name&gt; &lt;commit id/例如 f52c633&gt;看标签信息 git show &lt;tagname&gt;删除工作区标签 git tag -d &lt;tagname&gt;删除远程标签git push origin :refs/tags/&lt;tagname&gt;上传标签git push origin &lt;tagname&gt;上传全部标签git push origin --tags 自定义git让git有颜色git config --global color.ui true 忽略特殊文件12345git工作区根目录下创建一个特殊的 (.gitignore)文件，把需要忽略的文件名填入就行如果有的文件被忽略，git add -f &lt;file.name&gt;对.gitignore命令检查，查出来可以针对修改git check-ignore -v &lt;file.name&gt;##查找的文件名 配置别名12git config --global alias.&lt;简化name&gt; &lt;原name&gt;global是全局]]></content>
      <categories>
        <category>gitlearn</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次见面，请多指教]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99%2F20190829-%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 希望在这里分享自己的所学，交流自己的所想，谈谈自己的所见，聊聊自己的所悟。&emsp;&emsp; 境随心转，见证成长。]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
